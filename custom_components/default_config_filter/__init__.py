import asyncio
import logging
import os.path
from typing import Any, Collection, Dict, Final, FrozenSet, Mapping

import voluptuous as vol
from homeassistant.config_entries import ConfigEntry, SOURCE_IMPORT
from homeassistant.helpers import config_validation as cv
from homeassistant.helpers.typing import ConfigType, HomeAssistantType
from homeassistant.util.json import load_json, save_json

_LOGGER: Final = logging.getLogger(__name__)

DOMAIN: Final = "default_config_filter"
DATA_UPDATER: Final = DOMAIN + "_updaters"

CONFIG_SCHEMA: Final = vol.Schema(
    {
        vol.Optional(DOMAIN): vol.Any(
            vol.All(vol.Coerce(dict), {cv.string: cv.boolean}),
            vol.All(cv.ensure_list, [cv.string], lambda x: dict.fromkeys(x, True)),
        )
    },
    extra=vol.ALLOW_EXTRA,
)

_OVERRIDE_MANIFEST_VERSION: Final = "v0.0.1"

_OVERRIDE_INIT_CONTENTS: Final = """
\"\"\"Placeholder to instantiate default_config override.

!!! DO NOT EDIT THIS FILE DIRECTLY !!!\"\"\"

import logging

from homeassistant.components.default_config import *

logging.getLogger(__name__).info("Default configuration domain is utilizing filtering!")
"""


async def async_get_original_manifest_contents(hass: HomeAssistantType) -> Dict[str, Any]:
    from homeassistant.components.default_config import __file__ as init_file_path

    original_manifest_path = os.path.join(os.path.dirname(init_file_path), "manifest.json")
    return await hass.async_add_executor_job(load_json, original_manifest_path)


def extract_manifest_dependencies(manifest_contents: Mapping[str, Any]) -> FrozenSet[str]:
    try:
        return frozenset(manifest_contents["dependencies"])
    except KeyError:
        _LOGGER.warning(f"Unexpected lack of 'dependencies' key on manifest")
        return frozenset()


async def async_setup(hass: HomeAssistantType, config: ConfigType) -> bool:
    domain_config = config.get(DOMAIN)

    _LOGGER.debug(f"Setting up component: {DOMAIN}")

    if domain_config:
        if hass.config_entries.async_entries(DOMAIN):
            _LOGGER.debug("Another configuration entry exists")
        else:
            _LOGGER.debug("Initializing configuration flow")
            hass.async_create_task(
                hass.config_entries.flow.async_init(
                    DOMAIN,
                    context={"source": SOURCE_IMPORT},
                    data=domain_config,
                )
            )

    return True


async def async_get_first_write_path(hass: HomeAssistantType, write_paths: Collection[str]) -> str:
    if not write_paths:
        raise ValueError("no paths provided")
    for path in write_paths:
        write_path = os.path.join(path, "default_config")

        if os.path.isdir(write_path):
            return write_path

        try:
            await hass.async_add_executor_job(os.mkdir, write_path)
        except asyncio.CancelledError:
            raise
        except BaseException as exc:
            _LOGGER.warning(f"Could not create directory {write_path}: {repr(exc)}")
            continue
        else:
            return write_path
    raise RuntimeError("could not create a suitable path")


async def async_setup_entry(hass: HomeAssistantType, config_entry: ConfigEntry) -> bool:
    _LOGGER.debug("Setting up configuration entry for default_config filtering")

    try:
        import custom_components
    except ImportError:
        from homeassistant.exceptions import HomeAssistantError

        raise HomeAssistantError("Custom components directory could not be detected")

    # Retrieve original manifest contents
    original_manifest_contents = await async_get_original_manifest_contents(hass)
    original_dependencies = extract_manifest_dependencies(original_manifest_contents)

    # Derive generated override path
    generated_override_path = None
    for custom_components_package_path in custom_components.__path__:
        current_path = os.path.join(custom_components_package_path, "default_config")
        if os.path.isdir(current_path):
            generated_override_path = current_path
            break

    if generated_override_path is None:
        # Create generated override path
        generated_override_path = await async_get_first_write_path(hass, custom_components.__path__)

    generated_override_manifest_path = os.path.join(generated_override_path, "manifest.json")

    # Load current dependencies, if available
    must_write_manifest = not os.path.isfile(generated_override_manifest_path)
    if must_write_manifest:
        current_manifest_contents = {}
        current_dependencies = frozenset()
    else:
        current_manifest_contents = await hass.async_add_executor_job(
            load_json, generated_override_manifest_path
        )
        current_dependencies = extract_manifest_dependencies(current_manifest_contents)

    _LOGGER.debug(f"Current dependencies: {', '.join(current_dependencies)}")

    # Prepare resulting manifest dependencies
    options = config_entry.options
    resulting_dependencies = original_dependencies.difference(
        filter(options.__getitem__, options.keys())
    )

    must_write_manifest |= current_dependencies != resulting_dependencies

    _LOGGER.debug(f"Resulting dependencies: {', '.join(resulting_dependencies)}")

    # Update version, if required
    original_manifest_contents["version"] = _OVERRIDE_MANIFEST_VERSION
    if current_manifest_contents.get("version") != _OVERRIDE_MANIFEST_VERSION:
        must_write_manifest = True

    # Compare extra manifest keys
    this_manifest_contents = await hass.async_add_executor_job(
        load_json, os.path.join(os.path.dirname(__file__), "manifest.json")
    )
    for key in ("documentation", "issue_tracker"):
        if key in this_manifest_contents:
            value = this_manifest_contents[key]
            # Compare existing manifest with current manifest
            if current_manifest_contents.get(key) != value:
                must_write_manifest = True
            # Save for new manifest contents
            original_manifest_contents[key] = value
        elif key in original_manifest_contents:
            must_write_manifest = True

    # Write manifest
    if must_write_manifest:
        _LOGGER.warning("Dependencies update required")

        if generated_override_path is None:
            _LOGGER.debug(f"Generated override directory does not exist, creating new directory")
            await async_get_first_write_path(hass, custom_components.__path__)

        # Add custom component manifest data
        original_manifest_contents["name"] += " (filtered)"
        original_manifest_contents["dependencies"] = sorted(resulting_dependencies)

        # Save new manifest file
        await hass.async_add_executor_job(
            save_json, generated_override_manifest_path, original_manifest_contents
        )

    # Check if initialization script requires an update aswell
    generated_override_init_path = os.path.join(generated_override_path, "__init__.py")
    must_write_init = not os.path.isfile(generated_override_init_path)
    if not must_write_init:
        _LOGGER.debug(f"Performing comparison with existing initialization script")

        def _check_init():
            with open(generated_override_init_path, "r", encoding="utf-8") as f:
                contents = f.read()
            return contents != _OVERRIDE_INIT_CONTENTS

        must_write_init = await hass.async_add_executor_job(_check_init)

    if must_write_init:
        _LOGGER.debug(
            f"Generated override init does not exist or is different, "
            f"writing new initialization script"
        )

        def _write_init():
            with open(generated_override_init_path, "w", encoding="utf-8") as f:
                f.write(_OVERRIDE_INIT_CONTENTS)

        await hass.async_add_executor_job(_write_init)

    hass.data[DATA_UPDATER] = config_entry.add_update_listener(async_reload_entry)

    if must_write_manifest or must_write_init:
        _LOGGER.warning(f"Home Assistant restart is required to apply manifest changes")
        return False

    return True


async def async_reload_entry(hass: HomeAssistantType, config_entry: ConfigEntry) -> bool:
    return await hass.config_entries.async_reload(config_entry.entry_id)


async def async_unload_entry(hass: HomeAssistantType, config_entry: ConfigEntry) -> bool:
    listener = hass.data.get(DATA_UPDATER)
    if listener:
        listener()

    return True


async def async_remove_entry(hass: HomeAssistantType, config_entry: ConfigEntry) -> bool:
    try:
        from custom_components import default_config
    except ImportError:
        return True

    this_manifest_path = os.path.join(os.path.dirname(__file__), "manifest.json")
    this_manifest_contents = await hass.async_add_executor_job(load_json, this_manifest_path)

    documentation = this_manifest_contents["documentation"]
    issues = this_manifest_contents["issue_tracker"]

    from shutil import rmtree

    successful_removal = True
    for override_base_path in default_config.__path__:
        override_manifest_path = os.path.join(override_base_path, "manifest.json")

        try:
            override_manifest_contents = await hass.async_add_executor_job(
                load_json, override_manifest_path
            )
        except asyncio.CancelledError:
            raise
        except BaseException as exc:
            _LOGGER.error(f"Error loading manifest at {override_manifest_path}: {repr(exc)}")
            continue
        else:
            if (
                override_manifest_contents.get("documentation") == documentation
                and override_manifest_contents.get("issue_tracker") == issues
            ):
                try:
                    await hass.async_add_executor_job(rmtree, override_base_path)
                except asyncio.CancelledError:
                    raise
                except BaseException as exc:
                    successful_removal = False
                    _LOGGER.error(f"Error removing directory at {override_base_path}: {repr(exc)}")

    return successful_removal
